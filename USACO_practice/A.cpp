//made by bezdar
 
//⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿
//⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⣿
//⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿
//⣿⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿
//⣿⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿
//⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⣿⠄⠄⠄⠄⠄⠄⣿⣿⣿⠄⠄⣿⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿⣿⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿
//⠄⣿⠄⠄⠄⣿⠄⠄⠄⣿⣿⠄⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿
//⠄⠄⣿⠄⠄⣿⠄⠄⣿⠄⠄⠄⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿⣿⣿⣿⠄⣿
//⠄⠄⠄⣿⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⠄⣿
//⣿⣿⣿⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⣿
//⣿⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⣿⠄⠄⣿
//⠄⣿⠄⠄⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⠄⠄⠄⣿⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⣿
//⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿⣿⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿
//⠄⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿

#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template<class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;

//DEFINES-----------------------------------------DEFINES
#define dbg(v) cerr << "Line(" << __LINE__ << ") -> " << "#var" << " = " << (v) << endl;
#define dbg1(u, v) cerr << "Line(" << __LINE__ << ") -> " << "u" << " = " << (u) << ' ' << "v" << " = " << (v) << endl;
#define all(a) (a).begin(), (a).end()
#define ll long long
#define pb push_back
#define eb emplace_back
#define sz(a) (a).size()
#define vll vector<ll> 
#define pll pair<ll, ll>
#define vpll vector<pll>
#define vvll vector<vll>
#define rep(a, n) for (ll i = a; i < n; i++)
#define REP(a, n) for (ll i = a; i <= n; i++)
#define rall(a) (a).rbegin(), (a).rend()
//DEFINES------------------------------------------DEFINES

//CONSTANTS------------------------------------CONSTANTS
const ll MOD1 = 1e9 + 7;
const ll MOD2 = 1e9 + 9;
const long double EPS = 1e-9;
//CONSTANTS------------------------------------CONSTANTS

//TEMPLATES---------------------------------TEMPLATES
__int128_t read() {
    __int128_t x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

void print(__int128_t x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) {
        print(x / 10);
    }
    putchar(x % 10 + '0');
}

template<typename T>
istream& operator>>(istream& in, vector<T>& vec) {
    for (T& i : vec) {
        in >> i;
    }
    return in;
}

template<typename T>
ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << "[";
    for (size_t i = 0; i < vec.size(); i++) {
        os << vec[i];
        if (i != vec.size() - 1) {
            os << ", ";
        }
    }
    return os << "]";
}

template<typename T>
ostream& operator<<(ostream& os, const set<T>& s) {
    os << "{";
    for (auto it = s.begin(); it != s.end(); it++) {
        if (it != s.begin()) {
            os << ", ";
        }
        os << *it;
    }
    return os << "}";
}

template<typename T>
ostream& operator<<(ostream& os, const multiset<T> &ms) {
    os << "{";
    for (auto it = ms.begin(); it != ms.end(); it++) {
        if (it != ms.begin()) {
            os << ", ";
        }
        os << *it;
    }
    return os << "}";
}

template<typename K, typename V>
ostream& operator<<(ostream& os, const map<K, V>& m) {
    os << "{";
    for (auto it = m.begin(); it != m.end(); it++) {
        if (it != m.begin()) {
            os << ", ";
        }
        os << it->first << ": " << it->second;
    }
    return os << "}";
}

void print_args(const char* names) {
    cerr << names << '\n';
}

template<typename T, typename... Args>
void print_args(const char* names, const T& arg, const Args&... args) {
    const char* comma = strchr(names, ',');
    if (comma) {
        cerr.write(names, comma - names) << " = " << arg << ", ";
        print_args(comma + 1, args...);
    } else {
        cerr << names << " = " << arg << '\n';
    }
}

#define watch(...) if (debug) { print_args(#__VA_ARGS__, __VA_ARGS__); }
const ll debug = 1;

ll chmin(ll a, ll b) {
    a = min(a, b);
    return a;
}

ll chmax(ll a, ll b) {
    a = max(a, b);
    return a;
}

ll incmod(ll a, ll b, ll mod) {
    return ((a % mod) + (b % mod)) % mod;
}

ll difmod(ll a, ll b, ll mod) {
    ll cur = ((a % mod) - (b % mod) + mod) % mod;
    if (cur < 0) {
        cur += mod;
    }
    return cur;
}

ll mulmod(ll a, ll b, ll mod) {
    return ((a % mod) * (b % mod)) % mod;
}
//TEMPLATES--------------------------------TEMPLATES


//GEOMETRY------------------------------GEOMETRY
struct point {
    long double x, y;
    point () {
        x = 0.0, y = 0.0;
    }
    point (ll x_, ll y_) {
        x = x_, y = y_;
    }
    point operator +(point other) {
        return point(x + other.x, y + other.y);
    }
    point operator -(point other) {
        return point(x - other.x, y - other.y);
    }
    ll operator *(point other) {
        return x * other.x + y * other.y;
    }
    ll operator %(point other) {
        return x * other.y - y * other.x;
    }
    long double len() {
        return sqrt(x * x + y * y);
    }
    point operator*(long double l) {
        return point(x * l, y * l);
    }
    point operator /(long double l) {
        return point(x / l, y / l);
    }
    long double dist(point other) {
        return sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));
    }
};
istream& operator >> (istream& in, point &a) {
    in >> a.x >> a.y;
    return in;
}
ostream& operator << (ostream& os, point &b) {
    os << b.x << ' ' << b.y << '\n';
    return os;
}
struct circle {
    point center;
    long double radius;
    circle () {
        center.x = 0.0;
        center.y = 0.0;
        radius = 0.0;
    }
};
long double area_circle(circle a) {
	return 3.1415926 * a.radius * a.radius;
}

long double area_octagon(vector<point> &a) {
    if (a.empty()) return 0.0; // Проверка на пустоту
    long double ans = 0.0;
    ans += (a[0].x - a[a.size() - 1].x) * (a[a.size() - 1].y + a[0].y);
    for (size_t i = 0; i < a.size() - 1; i++) {
        ans += (a[i + 1].x - a[i].x) * (a[i + 1].y + a[i].y);
    }
    return abs(ans) / 2.0;
}

long double dist(point &a, point &b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
//GEOMETRY---------------------------------------GEOMETRY


//DSU---------------------------DSU
struct dsu{
	vector<ll> p, s;
	void init(ll n) {
		p.resize(n + 1, 0);
		s.resize(n + 1, 0);
		for (ll i = 1; i <= n; i++) {
			p[i] = i;
			s[i] = 1;
		}
	}
	ll leader(ll u) {
		return (p[u] == u ? u : p[u] = leader(p[u]));
	}
	void unite(ll a, ll b) {
		a = leader(a);
		b = leader(b);
		if (s[a] > s[b]) {
			swap(a, b);
		}
		s[b] += s[a];
		p[a] = b;
	}
};
//DSU---------------------------DSU


//MATH--------------------------------------MATH
ll gcd(ll a, ll b) {
    return (b ? gcd(b, a % b) : a + b);
}
ll lcm(ll a, ll b) {
    ll g = gcd(a, b);
    return a / g * b;
}
vll divisors(ll number) {
    vll ret;
    for (ll i = 1; i * i <= number; i++) {
        if (number % i == 0) {
            ret.pb(i);
            if (i * i != number) {
                ret.pb(number / i);
            }
        }
    }
    sort(all(ret));
    return ret;
}
vpll prime_divisors(ll number) {
    ll m = number;
    map<ll, ll> cnt;
    for (ll i = 2; i * i <= m; i++) {
        if (m % i == 0) {
            while (m % i == 0) {
                cnt[i]++;
                m /= i;
            }
        }
    }
    if (m != 1) {
        cnt[m]++;
    }
    vpll ret;
    for (auto [u, v] : cnt) {
        ret.eb(u, v);
    }
    return ret;
}
ll binpow(ll base, ll p, ll mod = MOD1) {
    if (p == 1) {
        return base;
    }
    if (p == 0) {
        return 1;
    }
    if (p % 2 == 0) {
        ll t = binpow(base, p / 2);
        return ((t % mod) * (t % mod)) % mod;
    } else {
        return binpow(base, p - 1, mod) * base % mod;
    }
}
ll inverse_element(ll x) {
    return binpow(x, MOD1 - 2);
}
ll divide(ll a, ll b) {
    return ((a % MOD1) * (inverse_element(b) % MOD1)) % MOD1;
}
//MATH-----------------------------MATH


//FILE READING--------------------FILE READING
void file(const string &a) {
	freopen((a + ".in").c_str(), "r", stdin);
	freopen((a + ".out").c_str(), "w", stdout);
}
//FILE READING--------------------FILE READING

//SEGTREE-------------------------SEGTREE
struct segtree {
    ll n;
    vvll count;
    vector<char> lazy;
    string s;
    segtree(const string &str) {
        s = str;
        n = str.size();
        count.resize(4 * n, vll(26, 0));
        lazy.resize(4 * n, 0);
        build(0, 0, n - 1);
    }
    void build(ll v, ll tl, ll tr) {
        if (tl == tr) {
            count[v][s[tl] - 'a'] = 1;
        } else {
            ll tm = (tl + tr) / 2;
            build(2 * v + 1, tl, tm);
            build(2 * v + 2, tm + 1, tr);
            for (ll i = 0; i < 26; i++) {
                count[v][i] = count[2 * v + 1][i] + count[2 * v + 2][i];
            }
        }
    }
    void push(ll v, ll tl, ll tr) {
        if (lazy[v]) {
            if (tl == tr) {
                s[tl] = lazy[v];
                for (ll i = 0; i < 26; i++) {
                    count[v][i] = 0;
                }
                count[v][lazy[v] - 'a'] = 1;
            } else {
                lazy[2 * v + 1] = lazy[v];
                lazy[2 * v + 2] = lazy[v];
                for (ll i = 0; i < 26; i++) {
                    count[v][i] = 0;
                }
                count[v][lazy[v] - 'a'] = tr - tl + 1;
            }
            lazy[v] = 0;
        }
    }
    vll query(ll v, ll tl, ll tr, ll l, ll r) {
        push(v, tl, tr);
        if (l > tr || r < tl) {
            return vll(26, 0);
        }
        if (l <= tl && tr <= r) {
            return count[v];
        }
        ll tm = (tl + tr) / 2;
        auto left = query(2 * v + 1, tl, tm, l, r);
        auto right = query(2 * v + 2, tm + 1, tr, l, r);
        vll res(26, 0);
        for (ll i = 0; i < 26; i++) {
            res[i] = left[i] + right[i];
        }
        return res;
    }
    void update(ll v, ll tl, ll tr, ll l, ll r, char new_char) {
        push(v, tl, tr);
        if (l > tr || r < tl) {
            return;
        }
        if (l <= tl && tr <= r) {
            lazy[v] = new_char;
            push(v, tl, tr);
            return;
        }
        ll tm = (tl + tr) / 2;
        update(2 * v + 1, tl, tm, l, r, new_char);
        update(2 * v + 2, tm + 1, tr, l, r, new_char);
        for (ll i = 0; i < 26; i++) {
            count[v][i] = count[2 * v + 1][i] + count[2 * v + 2][i];
        }
    }
    vll count_chars(ll l, ll r) {
        return query(0, 0, n - 1, l, r);
    }
    void assign_char(ll l, ll r, char new_char) {
        update(0, 0, n - 1, l, r, new_char);
    }
};
//SEGTREE-------------------------SEGTREE

//SOLVE---------------------------SOLVE

void solve() {
    long double start = clock();
	//----------------------------DO NOT TOUCH
    
    ll n; cin >> n;
    vector<pair<long double, long double>> pt(n + 1);
    rep(1, n + 1) {
        cin >> pt[i].first >> pt[i].second;
    }
    if (n == 1) {
        cout << 0;
        return;
    }

    dsu d;
    d.init(n + 1);

    vector<pair<pll, long double>> gr;
    for (ll i = 1; i < n; i++) {
        for (ll j = i + 1; j <= n; j++) {
            gr.pb({{i, j}, sqrt((pt[i].first - pt[j].first) * (pt[i].first - pt[j].first) + (pt[i].second - pt[j].second) * (pt[i].second - pt[j].second))});
        }
    }
    sort(all(gr), [](pair<pll, long double> u, pair<pll, long double> v) {
        return u.second < v.second;
    });
    long double ans = 0;
    for (ll i = 0; i < gr.size(); i++) {
        if (d.leader(gr[i].first.first) != d.leader(gr[i].first.second)) {
            ans += gr[i].second;
            d.unite(gr[i].first.first, gr[i].first.second);
        }
    }
    cout << fixed << setprecision(10) << ans;
    
    //----------------------------DO NOT TOUCH
    long double end = clock();
    cerr << '\n';
    dbg((end - start) / CLOCKS_PER_SEC);
}


//SOLVE----------------------SOLVE

//MAIN--------------------MAIN

#define DEBUG
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

#ifdef DEBUG
    freopen("unionday.in", "r", stdin);
    freopen("unionday.out", "w", stdout);
#endif
    ll test = 1;
    // cin >> test;
    for (ll i = 1; i <= test; i++) {
        dbg(i);
        solve();
        cout << '\n';
    }

    return 0;
}
//MAIN--------------------------MAIN
 
