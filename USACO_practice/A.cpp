//made by bezdar
 
 
 
//⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿
//⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⣿
//⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿
//⣿⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿
//⣿⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿
//⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⣿⠄⠄⠄⠄⠄⠄⣿⣿⣿⠄⠄⣿⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿⣿⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿
//⠄⣿⠄⠄⠄⣿⠄⠄⠄⣿⣿⠄⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿
//⠄⠄⣿⠄⠄⣿⠄⠄⣿⠄⠄⠄⣿⠄⠄⠄⠄⠄⣿⠄⠄⠄⣿⣿⣿⣿⠄⣿
//⠄⠄⠄⣿⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⠄⣿
//⣿⣿⣿⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⣿
//⣿⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⣿⠄⠄⣿
//⠄⣿⠄⠄⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⣿⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⠄⠄⠄⣿⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿
//⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⣿
//⠄⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿⣿⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⣿⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⠄⠄⠄⠄⣿
//⠄⠄⠄⣿⠄⠄⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠄⠄⠄⠄⣿⣿
//⠄⠄⣿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿

#include <bits/stdc++.h>

using namespace std;

#define dbg_time(v) cerr << "Line(" << __LINE__ << ") -> " << "#time" << " = " << (v) << endl;
#define dbg_var(v) cerr << "Line(" << __LINE__ << ") -> " << "#var" << " = " << (v) << endl;
#define dbg_ans(v) cerr << "Line(" << __LINE__ << ") -> " << "#ans" << " = " << (v) << endl;
#define dbg1(u, v) cerr << "Line(" << __LINE__ << ") -> " << "u " << " = " << (u) << ' ' << "v " << " = " << (v) << endl;
#define all(a) (a).begin(), (a).end()
#define EPS 1e-9
#define ll long long
#define pb push_back
#define eb emplace_back
#define sz(a) (a).size()
#define vll vector<ll> 
#define pll pair<ll, ll>
#define vpll vector<pll>
#define vvll vector<vll>
#define rep(a, n) for (ll i = a; i < n; i++)
#define REP(a, n) for (ll i = a; i <= n; i++)
#define rall(a) (a).rbegin(), (a).rend()

template <typename T>
istream& operator >> (istream& in, vector <T>& a) {
    for (T& i : a) {
        in >> i;
    }
    return in;
}
template <typename T>
ostream& operator << (ostream& out, vector <T>& a) {
    for (T& i : a) {
        out << i << ' ';
    }
    return out;
}
template<typename T, typename K>
istream& operator >> (istream& in, pair<T, K>& a) {
	in >> a.first >> a.second;
	return in;
}
template<typename T, typename K>
ostream& operator << (ostream& os, pair<T, K> &a) {
	os << a.first << ' ' << a.second;
	return os;
}
struct point {
    long double x, y;
    point () {
        x = 0.0, y = 0.0;
    }
    point (ll x_, ll y_) {
        x = x_, y = y_;
    }
    point operator +(point other) {
        return point(x + other.x, y + other.y);
    }
    point operator -(point other) {
        return point(x - other.x, y - other.y);
    }
    ll operator *(point other) {
        return x * other.x + y * other.y;
    }
    ll operator %(point other) {
        return x * other.y - y * other.x;
    }
    long double len() {
        return sqrt(x * x + y * y);
    }
    point operator*(long double l) {
        return point(x * l, y * l);
    }
    point operator /(long double l) {
        return point(x / l, y / l);
    }
    long double dist(point other) {
        return sqrt((x - other.x) * (x - other.x) + (y - other.y) * (y - other.y));
    }
};
istream& operator >> (istream& in, point &a) {
    in >> a.x >> a.y;
    return in;
}
ostream& operator << (ostream& os, point &b) {
    os << b.x << ' ' << b.y << '\n';
    return os;
}
struct circle {
    point center;
    long double radius;
    circle () {
        center.x = 0.0;
        center.y = 0.0;
        radius = 0.0;
    }
};
long double area_circle(circle a) {
	return 3.1415926 * a.radius * a.radius;
}

long double area_octagon(vector<point> &a) {
    if (a.empty()) return 0.0; // Проверка на пустоту
    long double ans = 0.0;
    ans += (a[0].x - a[a.size() - 1].x) * (a[a.size() - 1].y + a[0].y);
    for (ll i = 0; i < a.size() - 1; i++) {
        ans += (a[i + 1].x - a[i].x) * (a[i + 1].y + a[i].y);
    }
    return abs(ans) / 2.0;
}

long double dist(point &a, point &b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

struct dsu{
	vector<ll> p, s;
	void init(ll n) {
		p.resize(n + 1, 0);
		s.resize(n + 1, 0);
		for (ll i = 1; i <= n; i++) {
			p[i] = i;
			s[i] = 1;
		}
	}
	ll leader(ll u) {
		return (p[u] == u ? u : p[u] = leader(p[u]));
	}
	void unite(ll a, ll b) {
		a = leader(a);
		b = leader(b);
		if (s[a] > s[b]) {
			swap(a, b);
		}
		s[b] += s[a];
		p[a] = b;
	}
};

struct math {
	ll gcd(ll a, ll b) {
		return (b ? gcd(b, a % b) : a + b);
	}
	ll lcm(ll a, ll b) {
		ll g = gcd(a, b);
		return a / g * b;
	}
	vll divisors(ll number) {
		vll ret;
		for (ll i = 1; i * i <= number; i++) {
			if (number % i == 0) {
				ret.pb(i);
				if (i * i != number) {
					ret.pb(number / i);
				}
			}
		}
		sort(all(ret));
		return ret;
	}
	vpll prime_divisors(ll number) {
		ll m = number;
		map<ll, ll> cnt;
		for (ll i = 2; i * i <= m; i++) {
			if (m % i == 0) {
				while (m % i == 0) {
					cnt[i]++;
					m /= i;
				}
			}
		}
		if (m != 1) {
			cnt[m]++;
		}
		vpll ret;
		for (auto [u, v] : cnt) {
			ret.eb(u, v);
		}
		return ret;
	}
};

void file(const string &a) {
	freopen((a + ".in").c_str(), "r", stdin);
	freopen((a + ".out").c_str(), "w", stdout);
}

class SegmentTree {
private:
    vll tree; // Дерево отрезков для хранения сумм
    vll lazyAdd; // Для отложенного прибавления
    vll lazySet; // Для отложенного присвоения
    vector<bool> isSet; // Флаг, указывающий, было ли присвоение
    ll n;

    void build(ll node, ll start, ll end, const vector<ll>& arr) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            ll mid = (start + end) / 2;
            build(2 * node, start, mid, arr);
            build(2 * node + 1, mid + 1, end, arr);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }

    void applyLazy(ll node, ll start, ll end) {
        if (isSet[node]) {
            tree[node] = (end - start + 1) * lazySet[node];
            if (start != end) {
                lazySet[2 * node] = lazySet[node];
                lazySet[2 * node + 1] = lazySet[node];
                isSet[2 * node] = true;
                isSet[2 * node + 1] = true;
                lazyAdd[2 * node] = 0; // Сбрасываем отложенное прибавление
                lazyAdd[2 * node + 1] = 0;
            }
            isSet[node] = false;
        }

        if (lazyAdd[node] != 0) {
            tree[node] += (end - start + 1) * lazyAdd[node];
            if (start != end) {
                lazyAdd[2 * node] += lazyAdd[node];
                lazyAdd[2 * node + 1] += lazyAdd[node];
            }
            lazyAdd[node] = 0;
        }
    }

    void updateRangeSet(ll node, ll start, ll end, ll l, ll r, ll value) {
        applyLazy(node, start, end);

        if (start > end || start > r || end < l) {
            return;
        }

        if (start >= l && end <= r) {
            lazySet[node] = value;
            isSet[node] = true;
            applyLazy(node, start, end);
            return;
        }

        ll mid = (start + end) / 2;
        updateRangeSet(2 * node, start, mid, l, r, value);
        updateRangeSet(2 * node + 1, mid + 1, end, l, r, value);
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }

    void updateRangeAdd(ll node, ll start, ll end, ll l, ll r, ll value) {
        applyLazy(node, start, end);

        if (start > end || start > r || end < l) {
            return;
        }

        if (start >= l && end <= r) {
            lazyAdd[node] += value;
            applyLazy(node, start, end);
            return;
        }

        ll mid = (start + end) / 2;
        updateRangeAdd(2 * node, start, mid, l, r, value);
        updateRangeAdd(2 * node + 1, mid + 1, end, l, r, value);
        tree[node] = tree[2 * node] + tree[2 * node + 1];
    }

    ll query(ll node, ll start, ll end, ll l, ll r) {
        applyLazy(node, start, end);

        if (start > end || start > r || end < l) {
            return 0; // Нейтральный элемент для суммы
        }

        if (start >= l && end <= r) {
            return tree[node];
        }

        ll mid = (start + end) / 2;
        ll leftQuery = query(2 * node, start, mid, l, r);
        ll rightQuery = query(2 * node + 1, mid + 1, end, l, r);
        return leftQuery + rightQuery;
    }

public:
    SegmentTree(const vector<ll>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        lazyAdd.resize(4 * n, 0);
        lazySet.resize(4 * n, 0);
        isSet.resize(4 * n, false);
        build(1, 0, n - 1, arr);
    }

    void updateAdd(ll l, ll r, ll value) {
        updateRangeAdd(1, 0, n - 1, l, r, value);
    }

    void updateSet(ll l, ll r, ll value) {
        updateRangeSet(1, 0, n - 1, l, r, value);
    }

    long long query(ll l, ll r) {
        return query(1, 0, n - 1, l, r);
    }
};

struct Line {
    long double a, b, c;
    Line () {
        a = 0.0, b = 0.0, c = 0.0;
    }
    Line (long double a_, long double b_, long double c_) {
        a = a_, b = b_, c = c_;
    }
};

void solve() {
	
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    ll test = 1;
    while (test--) {
        solve();
        cout << '\n';
    }

    return 0;
}

